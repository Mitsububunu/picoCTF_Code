from pwn import *

# https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


ciphertext = 10100776446323352385493015091984129991654818551023717011426822964375906852204334475738871140019822845527513155730614262137870266100427015247367603826266431473478744373035944741640218653378650011684242516451163521069400164551558021767687829025973479863986276786593842625976673998482553334501837616199366239
n = 17243927499194110242286709137731948699041826383141153902184688040538235678296804902029184475947243190800119290006450125547457305346924886528143799975039565759694544686759836170961227296852341512379717302302905181749031444405106261625950331951945527142800094118176434824825676715529562605597660191100542033
e = 65537

phi = 8919945363333354406871752543500501513755577489123174151308992397436045664878067691065866493123674240815052865464496545807559835062509051860896266119562768119066818022580513745114186926803396678674388906281542836080266568283345906623450619555089908329316975517887404652387401054529443078340608000000000000

d = modinv(e, phi)
m = pow(ciphertext, d, n)

flag = unhex(hex(m)[2:])

print 'flag: {}'.format(flag)